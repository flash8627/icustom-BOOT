<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.gwtjs.icustom.springsecurity.jaxrs.dao.IRegionForecastDao">



	<update id="saveRegionForecast">
		begin
		<foreach collection='list' item="record" index="index">
			MERGE INTO dsf_forecast_region_header_t tar
			USING (SELECT #{record.demandEntityId, jdbcType=INTEGER} demand_entity_id,
			#{record.pdtType, jdbcType=VARCHAR} pdt_type,
			#{record.pdtId, jdbcType=VARCHAR} pdt_id,
			0 supply_entity_id,
			#{record.bucketDimension, jdbcType=VARCHAR} bucket_dimension,
			#{record.forecastDimensionCode, jdbcType=VARCHAR} forecast_dimension_code,
			#{record.forecastStatus, jdbcType=VARCHAR} forecast_status,
			#{record.deleteFlag, jdbcType=VARCHAR} delete_flag,
			0 created_by,
			'0' created_name,
			sysdate creation_date,
			#{record.currentUserId, jdbcType=DOUBLE} last_updated_by,
			#{record.currentUserCN, jdbcType=VARCHAR} last_updated_name,
			sysdate last_updated_date
			FROM dual) src
			ON (
			tar.DEMAND_ENTITY_ID= src.DEMAND_ENTITY_ID
			And tar.PDT_TYPE =src.PDT_TYPE
			And tar.PDT_ID = src.PDT_ID
			And tar.SUPPLY_ENTITY_ID = src.SUPPLY_ENTITY_ID
			And tar.BUCKET_DIMENSION = src.BUCKET_DIMENSION
			And tar.FORECAST_DIMENSION_CODE = src.FORECAST_DIMENSION_CODE
			)
			WHEN MATCHED THEN
			UPDATE SET
			tar.delete_flag = src.delete_flag,
			tar.last_updated_by = src.last_updated_by,
			tar.last_updated_name = src.last_updated_name,
			tar.last_update_date = src.last_updated_date,
			tar.forecast_status = nvl(src.forecast_status,tar.forecast_status)
			WHEN NOT MATCHED THEN
			INSERT
			(forecast_header_id,
			demand_entity_id,
			pdt_type,
			pdt_id,
			supply_entity_id,
			bucket_dimension,
			forecast_dimension_code,
			forecast_status,
			delete_flag,
			created_by,
			created_name,
			creation_date,
			last_updated_by,
			last_updated_name,
			last_update_date)
			VALUES
			(DSF_FORECAST_REGION_HEADER_S.nextval*1000,
			src.demand_entity_id,
			src.pdt_type,
			src.pdt_id,
			src.supply_entity_id,
			src.bucket_dimension,
			src.forecast_dimension_code,
			null,
			'Y',
			src.created_by,
			src.created_name,
			src.creation_date,
			src.created_by,
			src.created_name,
			src.creation_date);
		</foreach>
		commit;
		EXCEPTION
		WHEN OTHERS THEN
		ROLLBACK;
		raise_application_error(-20000, substr('ERROR:' || dbms_utility.format_error_backtrace ||
		SQLERRM || ':' || to_char(SQLCODE) || ' ' ||
		dbms_utility.format_error_stack || ' ' ||
		dbms_utility.format_call_stack,
		1,
		1000));
		End;
	</update>

	<sql id="sqlSelectForecast">
		Select gh.forecast_header_id forecastHeaderId,
		gh.pdt_type pdtType,
		gh.pdt_id pdtId,
		gh.supply_entity_id supplyEntityId,
		gh.bucket_dimension bucketDimension,
		gh.forecast_dimension_code forecastDimensionCode,
		gh.forecast_status forecastStatus,
		gh.delete_flag deleteFlag,
		gh.created_by createdBy,
		gh.created_name creationUserCN,
		gh.creation_date creationDate,
		gh.last_updated_by lastUpdatedBy,
		gh.last_updated_name lastUpdateUserCN,
		gh.last_update_date lastUpdateDate,

		pd.pdt_large_code pdtLargeCode,
		pd.pdt_large_name_cn pdtLargeNameCn,
		pd.pdt_large_name_en pdtLargeNameEn,
		pd.pdt_large_uom pdtLargeUom,

		fd.forecast_dimension_desc_cn forecastDimensionDescCn,
		fd.forecast_dimension_desc_en forecastDimensionDescEn,
		fd.forecast_dimension_category forecastDimensionCategory,
		fd.edit_flag editFlag,
		fd.rate_flag rateFlag,

		de.demand_entity_id demandentityid,
		de.bg_code bgcode,
		de.demand_entity_type demandentitytype,
		de.demand_entity_code demandentitycode,

		ao.area_org_name_cn areaOrgName,

		po.lv0_org_code lv0OrgCode,
		po.lv0_type_name lv0TypeName,
		po.lv0_org_name_cn lv0OrgNameCn,
		po.lv0_org_name_en lv0OrgNameEn,

		po.lv1_org_code lv1OrgCode,
		po.lv1_type_name lv1TypeName,
		po.lv1_org_name_cn lv1OrgNameCn,
		po.lv1_org_name_en lv1OrgNameEn,

		po.lv2_org_code lv2OrgCode,
		po.lv2_type_name lv2TypeName,
		po.lv2_org_name_cn lv2OrgNameCn,
		po.lv2_org_name_en lv2OrgNameEn,

		po.lv3_org_code lv3OrgCode,
		po.lv3_type_name lv3TypeName,
		po.lv3_org_name_cn lv3OrgNameCn,
		po.lv3_org_name_en lv3OrgNameEn,

		po.lv4_org_code lv4OrgCode,
		po.lv4_type_name lv4TypeName,
		po.lv4_org_name_cn lv4OrgNameCn,
		po.lv4_org_name_en lv4OrgNameEn

		FROM dsf_forecast_region_header_t gh

		JOIN dsf_demand_entity_t de
		ON (gh.demand_entity_id = de.demand_entity_id AND de.enable_flag = 'Y')

		JOIN dsf_area_org_t ao
		ON (ao.area_org_code = de.demand_entity_code AND
		upper(ao.area_org_type) = upper('REGION') AND de.demand_entity_id = gh.demand_entity_id)

		JOIN dsf_pdt_large_t pd
		ON (pd.pdt_large_id = gh.pdt_id AND pd.enable_flag = 'Y')

		JOIN dsf_pdt_org_t po
		ON (po.pdt_org_id = pd.pdt_org_id AND po.enable_flag = 'Y')

		JOIN dsf_forecast_dimension_t fd
		On (fd.forecast_dimension_code = gh.forecast_dimension_code AND
		fd.bg_code=#{vo.bgCode,jdbcType=VARCHAR}
		AND UPPER(fd.demand_entity_type) =
		UPPER(#{vo.demandEntityType,jdbcType=VARCHAR} )
		AND fd.bucket_dimension=#{vo.bucketDimension,jdbcType=VARCHAR})
	</sql>

	<sql id="sqlWhereForecast">
		where 1=1
		<if test='vo.bucketDimension != null and vo.bucketDimension !="" '>
			And gh.bucket_dimension = #{vo.bucketDimension, jdbcType=VARCHAR}
		</if>
		<if test='vo.bgCode != null and vo.bgCode !="" '>
			And de.bg_code = #{vo.bgCode, jdbcType=VARCHAR}
		</if>
		<if test='vo.pdtType != null and vo.pdtType !="" '>
			And gh.pdt_type = #{vo.pdtType, jdbcType=VARCHAR}
		</if>

		<if test='vo.pdtId != null and vo.pdtId !="" '>
			And gh.pdt_id = #{vo.pdtId,jdbcType=INTEGER}
		</if>
		<if test='vo.demandEntityId != null and vo.demandEntityId !="" '>
			And de.demand_entity_id = #{vo.demandEntityId, jdbcType=VARCHAR}
		</if>

		<if test='vo.demandEntityType != null and vo.demandEntityType !="" '>
			And UPPER(de.demand_entity_type) = UPPER(#{vo.demandEntityType,
			jdbcType=VARCHAR})
		</if>
		<if
			test='vo.forecastDimensionCategory != null and vo.forecastDimensionCategory !="" '>
			And fd.forecast_dimension_category = #{vo.forecastDimensionCategory,
			jdbcType=VARCHAR}
		</if>
		<if test='vo.forecastDimensionCodes != null'>
			And gh.forecast_dimension_code In
			<foreach collection='vo.forecastDimensionCodes' item="item"
				open="(" separator="," close=")" index="index">
				#{item}
			</foreach>
		</if>
		<if test='vo.forecastDimensionCodes == null'>
			and fd.main_flag = 'Y'
		</if>
		And gh.delete_flag = 'Y'
		and ( 1=2
		<if test='vo.lv1OrgCodes != null'>
			or po.lv1_org_code in
			<foreach collection='vo.lv1OrgCodes' item="item" open="("
				separator="," close=")" index="index">
				#{item}
			</foreach>
		</if>
		<if test='vo.lv2OrgCodes != null'>
			or po.lv2_org_code in
			<foreach collection='vo.lv2OrgCodes' item="item" open="("
				separator="," close=")" index="index">
				#{item}
			</foreach>
		</if>
		<if test='vo.lv3OrgCodes != null'>
			or po.lv3_org_code in
			<foreach collection='vo.lv3OrgCodes' item="item" open="("
				separator="," close=")" index="index">
				#{item}
			</foreach>
		</if>
		<if test='vo.pdtLargeCodes != null'>
			or gh.pdt_id in
			<foreach collection='vo.pdtLargeCode' item="item" open="("
				separator="," close=")" index="index">
				#{item}
			</foreach>
		</if>
		<if
			test='vo.lv1OrgCodes == null and vo.lv2OrgCodes == null and vo.lv3OrgCodes == null and vo.pdtLargeCodes == null '>
			or 1 = 1
		</if>
		)
		<if test='vo.forecastHeaderIds != null'>
			and ( 1=2
			<foreach collection="list" item="item">
				or (
				gh.forecast_header_id = #{item.forecastHeaderId,jdbcType=INTEGER}
				)
			</foreach>
			)
		</if>
	</sql>

	<select id="queryRegionCurrentForecast" resultType="com.gwtjs.icustom.springsecurity.entity.ForecastVO">
		Select *
		From (Select rownum rn, t.* From (
		<include refid="sqlSelectForecast" />
		<include refid="sqlWhereForecast" />
		Order By
		ao.area_org_code,po.lv0_org_code,po.lv1_org_code,po.lv2_org_code,po.lv3_org_code,gh.pdt_id,fd.sort_id
		) t
<![CDATA[WHERE rownum <= #{page.endIndex}]]>
		)
<![CDATA[WHERE rn >= #{page.startIndex}]]>
	</select>

	<select id="queryRegionCurrentForecastCount" resultType="int">
		Select count(*)
		From (
		<include refid="sqlSelectForecast" />
		<include refid="sqlWhereForecast" />
		)
	</select>

	<select id="queryRegionForecast" resultType="com.gwtjs.icustom.springsecurity.entity.ForecastVO">
		Select *
		From (Select rownum rn, t.* From (
		<include refid="sqlSelectForecast" />
		<include refid="sqlWhereForecast" />
		Order By
		ao.area_org_code,po.lv0_org_code,po.lv1_org_code,po.lv2_org_code,po.lv3_org_code,gh.pdt_id,fd.sort_id
		) t
<![CDATA[WHERE rownum <= #{page.endIndex}]]>
		)
<![CDATA[WHERE rn >= #{page.startIndex}]]>
	</select>

	<update id="initLargeTOForecast">
		begin
		MERGE INTO dsf_forecast_region_header_t tar
		USING (Select de.demand_entity_id demand_entity_id,
		'FAR-OUT' pdt_type,
		pl.pdt_large_id pdt_id,
		'0' supply_entity_id,
		fd.bucket_dimension bucket_dimension,
		fd.forecast_dimension_code forecast_dimension_code,
		NULL forecast_status,
		Case
		When de.enable_flag = 'Y' And pl.Enable_Flag = 'Y' And
		fd.enable_flag = 'Y' And po.enable_flag = 'Y' Then
		'Y'
		Else
		'N'
		End delete_flag,
		0 created_by,
		'0' created_name,
		Sysdate creation_date,
		0 last_updated_by,
		'0' last_updated_name,
		Sysdate last_updated_date
		FROM dsf_pdt_large_t pl
		JOIN dsf_forecast_dimension_t fd
		ON (1 = 1)
		Join dsf_demand_entity_t de
		On (de.bg_code = fd.bg_code And
		de.demand_entity_type = fd.demand_entity_type)
		Join dsf_pdt_org_t po
		On (po.pdt_org_id = pl.Pdt_Org_Id)
		Where fd.bg_code = #{vo.bgCode}
		and UPPER(fd.demand_entity_type) = UPPER(#{vo.demandEntityType})
		and fd.fo_flag = 'Y') src
		ON (tar.DEMAND_ENTITY_ID = src.DEMAND_ENTITY_ID And tar.PDT_TYPE =
		src.PDT_TYPE And tar.PDT_ID = src.PDT_ID And tar.SUPPLY_ENTITY_ID =
		src.SUPPLY_ENTITY_ID And tar.BUCKET_DIMENSION = src.BUCKET_DIMENSION
		And tar.FORECAST_DIMENSION_CODE = src.FORECAST_DIMENSION_CODE)
		WHEN MATCHED THEN
		UPDATE
		SET tar.delete_flag = src.delete_flag,
		tar.last_updated_by = src.last_updated_by,
		tar.last_updated_name = src.last_updated_name,
		tar.last_update_date = src.last_updated_date,
		tar.forecast_status = nvl(src.forecast_status,
		tar.forecast_status)
		WHEN NOT MATCHED THEN
		INSERT
		(forecast_header_id,
		demand_entity_id,
		pdt_type,
		pdt_id,
		supply_entity_id,
		bucket_dimension,
		forecast_dimension_code,
		forecast_status,
		delete_flag,
		created_by,
		created_name,
		creation_date,
		last_updated_by,
		last_updated_name,
		last_update_date)
		VALUES
		(dsf_forecast_region_header_s.nextval * 1000,
		src.demand_entity_id,
		src.pdt_type,
		src.pdt_id,
		src.supply_entity_id,
		src.bucket_dimension,
		src.forecast_dimension_code,
		null,
		'Y',
		src.created_by,
		src.created_name,
		src.creation_date,
		src.created_by,
		src.created_name,
		src.creation_date);
		commit;
		EXCEPTION
		WHEN OTHERS THEN
		ROLLBACK;
		raise_application_error(-20000,
		substr('ERROR:' ||
		dbms_utility.format_error_backtrace ||
		SQLERRM || ':' || to_char(SQLCODE) || ' ' ||
		dbms_utility.format_error_stack || ' ' ||
		dbms_utility.format_call_stack,
		1,
		1000));
		End;
	</update>

	<update id="initSmallTOForecast">
		begin
		MERGE INTO dsf_forecast_region_header_t tar
		USING (Select de.demand_entity_id demand_entity_id,
		'CLOSE-IN' pdt_type,
		pl.pdt_small_id pdt_id,
		'0' supply_entity_id,
		fd.bucket_dimension bucket_dimension,
		fd.forecast_dimension_code forecast_dimension_code,
		NULL forecast_status,
		Case
		When de.enable_flag = 'Y' And pl.Enable_Flag = 'Y' And
		fd.enable_flag = 'Y' And pa.enable_flag = 'Y' And
		po.enable_flag = 'Y' Then
		'Y'
		Else
		'N'
		End delete_flag,
		0 created_by,
		'0' created_name,
		Sysdate creation_date,
		0 last_updated_by,
		'0' last_updated_name,
		Sysdate last_updated_date

		FROM dsf_pdt_small_t pl
		JOIN dsf_forecast_dimension_t fd
		ON (1 = 1)
		Join dsf_demand_entity_t de
		On (de.bg_code = fd.bg_code And
		de.demand_entity_type = fd.demand_entity_type)
		Join dsf_pdt_large_t pa
		On (Pl.Pdt_Large_Id = pa.pdt_large_id)
		Join dsf_pdt_org_t po
		On (pa.pdt_org_id = po.pdt_org_id)
		Where fd.bg_code = #{vo.bgCode}
		and UPPER(fd.demand_entity_type) = UPPER(#{vo.demandEntityType})
		and fd.bucket_dimension = 'M'
		and fd.fo_flag = 'N') src
		ON (tar.DEMAND_ENTITY_ID = src.DEMAND_ENTITY_ID And tar.PDT_TYPE =
		src.PDT_TYPE And tar.PDT_ID = src.PDT_ID And tar.SUPPLY_ENTITY_ID =
		src.SUPPLY_ENTITY_ID And tar.BUCKET_DIMENSION = src.BUCKET_DIMENSION
		And tar.FORECAST_DIMENSION_CODE = src.FORECAST_DIMENSION_CODE)
		WHEN MATCHED THEN
		UPDATE
		SET tar.delete_flag = src.delete_flag,
		tar.last_updated_by = src.last_updated_by,
		tar.last_updated_name = src.last_updated_name,
		tar.last_update_date = src.last_updated_date,
		tar.forecast_status = nvl(src.forecast_status,
		tar.forecast_status)
		WHEN NOT MATCHED THEN
		INSERT
		(forecast_header_id,
		demand_entity_id,
		pdt_type,
		pdt_id,
		supply_entity_id,
		bucket_dimension,
		forecast_dimension_code,
		forecast_status,
		delete_flag,
		created_by,
		created_name,
		creation_date,
		last_updated_by,
		last_updated_name,
		last_update_date)
		VALUES
		(dsf_forecast_region_header_s.nextval * 1000,
		src.demand_entity_id,
		src.pdt_type,
		src.pdt_id,
		src.supply_entity_id,
		src.bucket_dimension,
		src.forecast_dimension_code,
		null,
		'Y',
		src.created_by,
		src.created_name,
		src.creation_date,
		src.created_by,
		src.created_name,
		src.creation_date);
		commit;
		EXCEPTION
		WHEN OTHERS THEN
		ROLLBACK;
		raise_application_error(-20000,
		substr('ERROR:' ||
		dbms_utility.format_error_backtrace ||
		SQLERRM || ':' || to_char(SQLCODE) || ' ' ||
		dbms_utility.format_error_stack || ' ' ||
		dbms_utility.format_call_stack,
		1,
		1000));
		End;
	</update>

</mapper>